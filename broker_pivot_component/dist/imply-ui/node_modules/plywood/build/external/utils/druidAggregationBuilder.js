import * as hasOwnProp from 'has-own-prop';
import { NamedArray } from 'immutable-class';
import { $, AbsoluteExpression, AddExpression, CastExpression, ChainableUnaryExpression, ConcatExpression, CountDistinctExpression, CountExpression, CustomAggregateExpression, DivideExpression, Expression, FallbackExpression, FilterExpression, IndexOfExpression, LiteralExpression, MaxExpression, MinExpression, MultiplyExpression, PowerExpression, QuantileExpression, RefExpression, SubtractExpression, SumExpression, TransformCaseExpression } from '../../expressions/index';
import { External } from '../baseExternal';
import { DruidExtractionFnBuilder } from './druidExtractionFnBuilder';
import { DruidFilterBuilder } from './druidFilterBuilder';
var APPROX_HISTOGRAM_TUNINGS = [
    "resolution",
    "numBuckets",
    "lowerLimit",
    "upperLimit"
];
var DruidAggregationBuilder = (function () {
    function DruidAggregationBuilder(options) {
        this.version = options.version;
        this.rawAttributes = options.rawAttributes;
        this.timeAttribute = options.timeAttribute;
        this.derivedAttributes = options.derivedAttributes;
        this.customAggregations = options.customAggregations;
        this.customTransforms = options.customTransforms;
        this.rollup = options.rollup;
        this.exactResultsOnly = options.exactResultsOnly;
        this.allowEternity = options.allowEternity;
    }
    DruidAggregationBuilder.prototype.makeAggregationsAndPostAggregations = function (applies) {
        var _this = this;
        var _a = External.segregationAggregateApplies(applies.map(function (apply) {
            var expression = apply.expression;
            expression = _this.switchToRollupCount(_this.inlineDerivedAttributesInAggregate(expression).decomposeAverage()).distribute();
            return apply.changeExpression(expression);
        })), aggregateApplies = _a.aggregateApplies, postAggregateApplies = _a.postAggregateApplies;
        var aggregations = [];
        var postAggregations = [];
        for (var _i = 0, aggregateApplies_1 = aggregateApplies; _i < aggregateApplies_1.length; _i++) {
            var aggregateApply = aggregateApplies_1[_i];
            this.applyToAggregation(aggregateApply, aggregations, postAggregations);
        }
        for (var _b = 0, postAggregateApplies_1 = postAggregateApplies; _b < postAggregateApplies_1.length; _b++) {
            var postAggregateApply = postAggregateApplies_1[_b];
            this.applyToPostAggregation(postAggregateApply, aggregations, postAggregations);
        }
        return {
            aggregations: aggregations,
            postAggregations: postAggregations
        };
    };
    DruidAggregationBuilder.prototype.applyToAggregation = function (action, aggregations, postAggregations) {
        var name = action.name, expression = action.expression;
        aggregations.push(this.expressionToAggregation(name, expression, postAggregations));
    };
    DruidAggregationBuilder.prototype.applyToPostAggregation = function (apply, aggregations, postAggregations) {
        var postAgg = this.expressionToPostAggregation(apply.expression, aggregations, postAggregations);
        postAgg.name = apply.name;
        postAggregations.push(postAgg);
    };
    DruidAggregationBuilder.prototype.filterAggregateIfNeeded = function (datasetExpression, aggregator) {
        if (datasetExpression instanceof FilterExpression) {
            return {
                type: "filtered",
                name: aggregator.name,
                filter: new DruidFilterBuilder(this).timelessFilterToFilter(datasetExpression.expression, true),
                aggregator: aggregator
            };
        }
        else if (datasetExpression instanceof RefExpression) {
            return aggregator;
        }
        else {
            throw new Error("could not construct aggregate on " + datasetExpression);
        }
    };
    DruidAggregationBuilder.prototype.expressionToAggregation = function (name, expression, postAggregations) {
        if (expression instanceof CountExpression) {
            return this.countToAggregation(name, expression);
        }
        else if (expression instanceof SumExpression || expression instanceof MinExpression || expression instanceof MaxExpression) {
            return this.sumMinMaxToAggregation(name, expression);
        }
        else if (expression instanceof CountDistinctExpression) {
            return this.countDistinctToAggregation(name, expression, postAggregations);
        }
        else if (expression instanceof QuantileExpression) {
            return this.quantileToAggregation(name, expression, postAggregations);
        }
        else if (expression instanceof CustomAggregateExpression) {
            return this.customAggregateToAggregation(name, expression, postAggregations);
        }
        else {
            throw new Error("unsupported aggregate action " + expression + " (as " + name + ")");
        }
    };
    DruidAggregationBuilder.prototype.countToAggregation = function (name, expression) {
        return this.filterAggregateIfNeeded(expression.operand, {
            name: name,
            type: 'count'
        });
    };
    DruidAggregationBuilder.prototype.sumMinMaxToAggregation = function (name, expression) {
        var aggregation;
        var aggregateExpression = expression.expression;
        if (aggregateExpression instanceof RefExpression) {
            var refName = aggregateExpression.name;
            var attributeInfo = this.getAttributesInfo(refName);
            if (attributeInfo.nativeType === 'STRING') {
                aggregation = this.makeJavaScriptAggregation(name, expression);
            }
            else {
                var op = expression.op;
                aggregation = {
                    name: name,
                    type: (attributeInfo.nativeType === 'LONG' ? 'long' : 'double') + op[0].toUpperCase() + op.substr(1),
                    fieldName: refName
                };
            }
        }
        else {
            aggregation = this.makeJavaScriptAggregation(name, expression);
        }
        return this.filterAggregateIfNeeded(expression.operand, aggregation);
    };
    DruidAggregationBuilder.prototype.getCardinalityExpressions = function (expression) {
        var _this = this;
        if (expression instanceof LiteralExpression) {
            return [];
        }
        else if (expression instanceof CastExpression) {
            return [expression.operand];
        }
        else if (expression instanceof ConcatExpression) {
            var subEx = expression.getExpressionList().map(function (ex) { return _this.getCardinalityExpressions(ex); });
            return [].concat.apply([], subEx);
        }
        else if (expression.getFreeReferences().length === 1) {
            return [expression];
        }
        else {
            throw new Error("can not convert " + expression + " to cardinality expressions");
        }
    };
    DruidAggregationBuilder.prototype.countDistinctToAggregation = function (name, expression, postAggregations) {
        var _this = this;
        if (this.exactResultsOnly) {
            throw new Error("approximate query not allowed");
        }
        var aggregation;
        var attribute = expression.expression;
        if (attribute instanceof RefExpression) {
            var attributeName = attribute.name;
            var attributeInfo = this.getAttributesInfo(attributeName);
            if (attributeInfo.nativeType === 'hyperUnique') {
                aggregation = {
                    name: name,
                    type: "hyperUnique",
                    fieldName: attributeName
                };
            }
            else if (attributeInfo.nativeType === 'thetaSketch') {
                var tempName = '!Theta_' + name;
                postAggregations.push({
                    type: "thetaSketchEstimate",
                    name: name,
                    field: { type: 'fieldAccess', fieldName: tempName }
                });
                aggregation = {
                    name: tempName,
                    type: "thetaSketch",
                    fieldName: attributeName
                };
            }
            else {
                aggregation = {
                    name: name,
                    type: "cardinality",
                    fields: [attributeName]
                };
            }
        }
        else {
            var cardinalityExpressions = this.getCardinalityExpressions(attribute);
            var druidExtractionFnBuilder_1;
            aggregation = {
                name: name,
                type: "cardinality",
                fields: cardinalityExpressions.map(function (cardinalityExpression) {
                    if (cardinalityExpression instanceof RefExpression)
                        return cardinalityExpression.name;
                    if (_this.versionBefore('0.9.2'))
                        throw new Error("can not have complex expression like " + cardinalityExpression + " in cardinality in Druid < 0.9.2");
                    if (!druidExtractionFnBuilder_1)
                        druidExtractionFnBuilder_1 = new DruidExtractionFnBuilder(_this);
                    return {
                        type: "extraction",
                        dimension: cardinalityExpression.getFreeReferences()[0],
                        extractionFn: druidExtractionFnBuilder_1.expressionToExtractionFn(cardinalityExpression)
                    };
                })
            };
            if (cardinalityExpressions.length > 1)
                aggregation.byRow = true;
        }
        if (aggregation.type === "cardinality" && this.versionBefore('0.9.2')) {
            aggregation.fieldNames = aggregation.fields;
            delete aggregation.fields;
        }
        return this.filterAggregateIfNeeded(expression.operand, aggregation);
    };
    DruidAggregationBuilder.prototype.customAggregateToAggregation = function (name, expression, postAggregations) {
        var customAggregationName = expression.custom;
        var customAggregation = this.customAggregations[customAggregationName];
        if (!customAggregation)
            throw new Error("could not find '" + customAggregationName + "'");
        var aggregationObj = customAggregation.aggregation;
        if (typeof aggregationObj.type !== 'string')
            throw new Error("must have type in custom aggregation '" + customAggregationName + "'");
        try {
            aggregationObj = JSON.parse(JSON.stringify(aggregationObj));
        }
        catch (e) {
            throw new Error("must have JSON custom aggregation '" + customAggregationName + "'");
        }
        var postAggregationObj = customAggregation.postAggregation;
        if (postAggregationObj) {
            try {
                postAggregationObj = JSON.parse(JSON.stringify(postAggregationObj));
            }
            catch (e) {
                throw new Error("must have JSON custom post aggregation '" + customAggregationName + "'");
            }
            postAggregationObj.name = name;
            postAggregations.push(postAggregationObj);
        }
        else {
            aggregationObj.name = name;
        }
        return aggregationObj;
    };
    DruidAggregationBuilder.prototype.quantileToAggregation = function (name, expression, postAggregations) {
        if (this.exactResultsOnly) {
            throw new Error("approximate query not allowed");
        }
        var attribute = expression.expression;
        var attributeName;
        if (attribute instanceof RefExpression) {
            attributeName = attribute.name;
        }
        else {
            throw new Error("can not compute quantile on derived attribute: " + attribute);
        }
        var tuning = Expression.parseTuning(expression.tuning);
        var attributeInfo = this.getAttributesInfo(attributeName);
        var histogramAggregationName = "!H_" + name;
        var aggregation = {
            name: histogramAggregationName,
            type: 'approxHistogram' + (attributeInfo.nativeType === 'approximateHistogram' ? 'Fold' : ''),
            fieldName: attributeName
        };
        for (var _i = 0, APPROX_HISTOGRAM_TUNINGS_1 = APPROX_HISTOGRAM_TUNINGS; _i < APPROX_HISTOGRAM_TUNINGS_1.length; _i++) {
            var k = APPROX_HISTOGRAM_TUNINGS_1[_i];
            if (!isNaN(tuning[k])) {
                aggregation[k] = Number(tuning[k]);
            }
        }
        postAggregations.push({
            name: name,
            type: "quantile",
            fieldName: histogramAggregationName,
            probability: expression.value
        });
        return aggregation;
    };
    DruidAggregationBuilder.prototype.makeJavaScriptAggregation = function (name, aggregate) {
        if (aggregate instanceof ChainableUnaryExpression) {
            var aggregateType = aggregate.op;
            var aggregateExpression = aggregate.expression;
            var aggregateFunction = DruidAggregationBuilder.AGGREGATE_TO_FUNCTION[aggregateType];
            if (!aggregateFunction)
                throw new Error("Can not convert " + aggregateType + " to JS");
            var zero = DruidAggregationBuilder.AGGREGATE_TO_ZERO[aggregateType];
            var fieldNames = aggregateExpression.getFreeReferences();
            var simpleFieldNames = fieldNames.map(RefExpression.toJavaScriptSafeName);
            return {
                name: name,
                type: "javascript",
                fieldNames: fieldNames,
                fnAggregate: "function($$," + simpleFieldNames.join(',') + ") { return " + aggregateFunction('$$', aggregateExpression.getJS(null)) + "; }",
                fnCombine: "function(a,b) { return " + aggregateFunction('a', 'b') + "; }",
                fnReset: "function() { return " + zero + "; }"
            };
        }
        else {
            throw new Error("Can not convert " + aggregate + " to JS aggregate");
        }
    };
    DruidAggregationBuilder.prototype.getAccessTypeForAggregation = function (aggregationType) {
        if (aggregationType === 'hyperUnique' || aggregationType === 'cardinality')
            return 'hyperUniqueCardinality';
        var customAggregations = this.customAggregations;
        for (var customName in customAggregations) {
            if (!hasOwnProp(customAggregations, customName))
                continue;
            var customAggregation = customAggregations[customName];
            if (customAggregation.aggregation.type === aggregationType) {
                return customAggregation.accessType || 'fieldAccess';
            }
        }
        return 'fieldAccess';
    };
    DruidAggregationBuilder.prototype.getAccessType = function (aggregations, aggregationName) {
        for (var _i = 0, aggregations_1 = aggregations; _i < aggregations_1.length; _i++) {
            var aggregation = aggregations_1[_i];
            if (aggregation.name === aggregationName) {
                var aggregationType = aggregation.type;
                if (aggregationType === 'filtered')
                    aggregationType = aggregation.aggregator.type;
                return this.getAccessTypeForAggregation(aggregationType);
            }
        }
        return 'fieldAccess';
    };
    DruidAggregationBuilder.prototype.expressionToPostAggregation = function (ex, aggregations, postAggregations) {
        var _this = this;
        if (ex instanceof RefExpression) {
            var refName = ex.name;
            return {
                type: this.getAccessType(aggregations, refName),
                fieldName: refName
            };
        }
        else if (ex instanceof LiteralExpression) {
            if (ex.type !== 'NUMBER')
                throw new Error("must be a NUMBER type");
            return {
                type: 'constant',
                value: ex.value
            };
        }
        else if (ex instanceof AbsoluteExpression ||
            ex instanceof PowerExpression ||
            ex instanceof FallbackExpression ||
            ex instanceof CastExpression ||
            ex instanceof IndexOfExpression ||
            ex instanceof TransformCaseExpression) {
            var fieldNameRefs = ex.getFreeReferences();
            var fieldNames = fieldNameRefs.map(function (fieldNameRef) {
                var accessType = _this.getAccessType(aggregations, fieldNameRef);
                if (accessType === 'fieldAccess')
                    return fieldNameRef;
                var fieldNameRefTemp = '!F_' + fieldNameRef;
                postAggregations.push({
                    name: fieldNameRefTemp,
                    type: accessType,
                    fieldName: fieldNameRef
                });
                return fieldNameRefTemp;
            });
            return {
                name: 'dummy',
                type: 'javascript',
                fieldNames: fieldNames,
                'function': "function(" + fieldNameRefs.map(RefExpression.toJavaScriptSafeName) + ") { return " + ex.getJS(null) + "; }"
            };
        }
        else if (ex instanceof AddExpression) {
            return {
                type: 'arithmetic',
                fn: '+',
                fields: ex.getExpressionList().map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
            };
        }
        else if (ex instanceof SubtractExpression) {
            return {
                type: 'arithmetic',
                fn: '-',
                fields: ex.getExpressionList().map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
            };
        }
        else if (ex instanceof MultiplyExpression) {
            return {
                type: 'arithmetic',
                fn: '*',
                fields: ex.getExpressionList().map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
            };
        }
        else if (ex instanceof DivideExpression) {
            return {
                type: 'arithmetic',
                fn: '/',
                fields: ex.getExpressionList().map(function (e) { return _this.expressionToPostAggregation(e, aggregations, postAggregations); })
            };
        }
        else {
            throw new Error("can not convert expression to post agg: " + ex);
        }
    };
    DruidAggregationBuilder.prototype.switchToRollupCount = function (expression) {
        var _this = this;
        if (!this.rollup)
            return expression;
        var countRef = null;
        return expression.substitute(function (ex) {
            if (ex instanceof CountExpression) {
                if (!countRef)
                    countRef = $(_this.getRollupCountName(), 'NUMBER');
                return ex.operand.sum(countRef);
            }
            return null;
        });
    };
    DruidAggregationBuilder.prototype.getRollupCountName = function () {
        var rawAttributes = this.rawAttributes;
        for (var _i = 0, rawAttributes_1 = rawAttributes; _i < rawAttributes_1.length; _i++) {
            var attribute = rawAttributes_1[_i];
            var maker = attribute.maker;
            if (maker && maker.op === 'count')
                return attribute.name;
        }
        throw new Error("could not find rollup count");
    };
    DruidAggregationBuilder.prototype.inlineDerivedAttributes = function (expression) {
        var derivedAttributes = this.derivedAttributes;
        return expression.substitute(function (refEx) {
            if (refEx instanceof RefExpression) {
                return derivedAttributes[refEx.name] || null;
            }
            else {
                return null;
            }
        });
    };
    DruidAggregationBuilder.prototype.inlineDerivedAttributesInAggregate = function (expression) {
        var _this = this;
        return expression.substitute(function (ex) {
            if (ex.isAggregate()) {
                return _this.inlineDerivedAttributes(ex);
            }
            return null;
        });
    };
    DruidAggregationBuilder.prototype.getAttributesInfo = function (attributeName) {
        return NamedArray.get(this.rawAttributes, attributeName);
    };
    DruidAggregationBuilder.prototype.versionBefore = function (neededVersion) {
        var version = this.version;
        return version && External.versionLessThan(version, neededVersion);
    };
    DruidAggregationBuilder.AGGREGATE_TO_FUNCTION = {
        sum: function (a, b) { return a + "+" + b; },
        min: function (a, b) { return "Math.min(" + a + "," + b + ")"; },
        max: function (a, b) { return "Math.max(" + a + "," + b + ")"; }
    };
    DruidAggregationBuilder.AGGREGATE_TO_ZERO = {
        sum: "0",
        min: "Infinity",
        max: "-Infinity"
    };
    return DruidAggregationBuilder;
}());
export { DruidAggregationBuilder };
