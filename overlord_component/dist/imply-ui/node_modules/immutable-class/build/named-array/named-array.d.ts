export interface Nameable {
    name: string;
}
export interface SynchronizerOptions<T> {
    key?: (thing: T, index?: number) => string;
    equals?: (thingA: T, thingB: T) => boolean;
    onEnter?: (newThing: T) => void;
    onUpdate?: (newThing: T, oldThing: T) => void;
    onExit?: (oldThing: T) => void;
}
export interface DiffJS {
    before?: any;
    after?: any;
}
export declare class Diff<T extends Nameable> {
    static inflateFromJS<T extends Nameable>(Class: {
        fromJS: (js: any) => T;
    }, diffJS: DiffJS): Diff<T>;
    static inflateFromJSs<T extends Nameable>(Class: {
        fromJS: (js: any) => T;
    }, diffJSs: DiffJS[]): Diff<T>[];
    before?: T;
    after?: T;
    constructor(before: T | null, after: T | null);
    toJS(): DiffJS;
    toJSON(): DiffJS;
    getName(): string;
}
export declare class NamedArray {
    static isValid<T extends Nameable>(array: T[]): boolean;
    static checkValid<T extends Nameable>(array: T[]): void;
    static get<T extends Nameable>(array: T[], name: string): T;
    static containsByName<T extends Nameable>(array: T[], name: string): boolean;
    static findByNameCI<T extends Nameable>(array: T[], name: string): T;
    static findByName<T extends Nameable>(array: T[], name: string): T;
    static findIndexByName<T extends Nameable>(array: T[], name: string): number;
    static overrideByName<T extends Nameable>(things: T[], thingOverride: T): T[];
    static overridesByName<T extends Nameable>(things: T[], thingOverrides: T[]): T[];
    static deleteByName<T extends Nameable>(array: T[], name: string): T[];
    static synchronize<T>(oldThings: T[], newThings: T[], updatedOptions: SynchronizerOptions<T>): void;
    static computeDiffs<T extends Nameable>(oldThings: T[], newThings: T[]): Diff<T>[];
}
