import { isDate } from 'chronoshift';
import { NamedArray } from 'immutable-class';
import { NumberRange, Range, Set, TimeRange } from '../../datatypes/index';
import { AndExpression, ContainsExpression, Expression, IsExpression, LiteralExpression, MatchExpression, NotExpression, OrExpression, OverlapExpression, RefExpression } from '../../expressions/index';
import { External } from '../baseExternal';
import { DruidExtractionFnBuilder } from './druidExtractionFnBuilder';
var DruidFilterBuilder = (function () {
    function DruidFilterBuilder(options) {
        this.version = options.version;
        this.rawAttributes = options.rawAttributes;
        this.timeAttribute = options.timeAttribute;
        this.allowEternity = options.allowEternity;
        this.customTransforms = options.customTransforms;
    }
    DruidFilterBuilder.prototype.filterToDruid = function (filter) {
        var _this = this;
        if (!filter.canHaveType('BOOLEAN'))
            throw new Error("can not filter on " + filter.type);
        if (filter.equals(Expression.FALSE)) {
            return {
                intervals: [],
                filter: null
            };
        }
        else {
            var _a = filter.extractFromAnd(function (ex) {
                return (ex instanceof IsExpression || ex instanceof OverlapExpression) && _this.isTimeRef(ex.operand) && ex.expression instanceof LiteralExpression;
            }), extract = _a.extract, rest = _a.rest;
            return {
                intervals: this.timeFilterToIntervals(extract),
                filter: this.timelessFilterToFilter(rest, false)
            };
        }
    };
    DruidFilterBuilder.prototype.timeFilterToIntervals = function (filter) {
        if (!filter.canHaveType('BOOLEAN'))
            throw new Error("can not filter on " + filter.type);
        if (filter instanceof LiteralExpression) {
            if (!filter.value)
                return [];
            if (!this.allowEternity)
                throw new Error('must filter on time unless the allowEternity flag is set');
            return DruidFilterBuilder.TRUE_INTERVAL;
        }
        else if (filter instanceof IsExpression) {
            var lhs = filter.operand, rhs = filter.expression;
            if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                return this.valueToIntervals(rhs.value);
            }
            else {
                throw new Error("can not convert " + filter + " to Druid interval");
            }
        }
        else if (filter instanceof OverlapExpression) {
            var lhs = filter.operand, rhs = filter.expression;
            if (lhs instanceof RefExpression && rhs instanceof LiteralExpression) {
                return this.valueToIntervals(rhs.value);
            }
            else {
                throw new Error("can not convert " + filter + " to Druid intervals");
            }
        }
        else {
            throw new Error("can not convert " + filter + " to Druid intervals");
        }
    };
    DruidFilterBuilder.prototype.timelessFilterToFilter = function (filter, aggregatorFilter) {
        var _this = this;
        if (!filter.canHaveType('BOOLEAN'))
            throw new Error("can not filter on " + filter.type);
        if (filter instanceof RefExpression) {
            filter = filter.is(true);
        }
        if (filter instanceof LiteralExpression) {
            if (filter.value === true) {
                return null;
            }
            else {
                throw new Error("should never get here");
            }
        }
        else if (filter instanceof NotExpression) {
            return {
                type: 'not',
                field: this.timelessFilterToFilter(filter.operand, aggregatorFilter)
            };
        }
        else if (filter instanceof AndExpression) {
            return {
                type: 'and',
                fields: filter.getExpressionList().map(function (p) { return _this.timelessFilterToFilter(p, aggregatorFilter); })
            };
        }
        else if (filter instanceof OrExpression) {
            return {
                type: 'or',
                fields: filter.getExpressionList().map(function (p) { return _this.timelessFilterToFilter(p, aggregatorFilter); })
            };
        }
        else if (filter instanceof IsExpression) {
            var lhs = filter.operand, rhs = filter.expression;
            if (rhs instanceof LiteralExpression) {
                if (Set.isSetType(rhs.type)) {
                    return this.makeInFilter(lhs, rhs.value);
                }
                else {
                    return this.makeSelectorFilter(lhs, rhs.value);
                }
            }
            else {
                throw new Error("can not convert " + filter + " to Druid filter");
            }
        }
        else if (aggregatorFilter && this.versionBefore('0.9.1')) {
            if (this.versionBefore('0.8.2'))
                throw new Error("can not express aggregate filter " + filter + " in druid < 0.8.2");
            return this.makeExtractionFilter(filter);
        }
        else if (filter instanceof OverlapExpression) {
            var lhs_1 = filter.operand, rhs = filter.expression;
            if (rhs instanceof LiteralExpression) {
                var rhsType = rhs.type;
                if (rhsType === 'SET/STRING' || rhsType === 'SET/NUMBER' || rhsType === 'SET/NULL') {
                    return this.makeInFilter(lhs_1, rhs.value);
                }
                else if (Set.unwrapSetType(rhsType) === 'TIME_RANGE' && this.isTimeRef(lhs_1)) {
                    return this.makeIntervalFilter(lhs_1, rhs.value);
                }
                else if (rhsType === 'NUMBER_RANGE' || rhsType === 'TIME_RANGE' || rhsType === 'STRING_RANGE') {
                    return this.makeBoundFilter(lhs_1, rhs.value);
                }
                else if (rhsType === 'SET/NUMBER_RANGE' || rhsType === 'SET/TIME_RANGE' || rhsType === 'SET/STRING_RANGE') {
                    return {
                        type: "or",
                        fields: rhs.value.elements.map(function (range) { return _this.makeBoundFilter(lhs_1, range); })
                    };
                }
                else {
                    throw new Error("not supported OVERLAP rhs type " + rhsType);
                }
            }
            else {
                throw new Error("can not convert " + filter + " to Druid filter");
            }
        }
        else if (filter instanceof MatchExpression) {
            return this.makeRegexFilter(filter.operand, filter.regexp);
        }
        else if (filter instanceof ContainsExpression) {
            var lhs = filter.operand, rhs = filter.expression, compare = filter.compare;
            return this.makeContainsFilter(lhs, rhs, compare);
        }
        else {
            throw new Error("could not convert filter " + filter + " to Druid filter");
        }
    };
    DruidFilterBuilder.prototype.checkFilterExtractability = function (attributeInfo) {
        if (this.versionBefore('0.9.2') && attributeInfo.name === this.timeAttribute) {
            throw new Error('can not do secondary filtering on primary time dimension (https://github.com/druid-io/druid/issues/2816)');
        }
    };
    DruidFilterBuilder.prototype.makeJavaScriptFilter = function (ex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        this.checkFilterExtractability(attributeInfo);
        return {
            type: "javascript",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            "function": ex.getJSFn('d')
        };
    };
    DruidFilterBuilder.prototype.valueToIntervals = function (value) {
        if (isDate(value)) {
            return TimeRange.intervalFromDate(value);
        }
        else if (value instanceof TimeRange) {
            return value.toInterval();
        }
        else if (value instanceof Set) {
            return value.elements.map(function (v) {
                if (isDate(v)) {
                    return TimeRange.intervalFromDate(v);
                }
                else if (v instanceof TimeRange) {
                    return v.toInterval();
                }
                else {
                    throw new Error("can not convert set value " + JSON.stringify(v) + " to Druid interval");
                }
            });
        }
        else {
            throw new Error("can not convert " + JSON.stringify(value) + " to Druid intervals");
        }
    };
    DruidFilterBuilder.prototype.makeExtractionFilter = function (ex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        return {
            type: "extraction",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            extractionFn: extractionFn,
            value: "true"
        };
    };
    DruidFilterBuilder.prototype.makeSelectorFilter = function (ex, value) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        if (attributeInfo.unsplitable) {
            throw new Error("can not convert " + ex + " = " + value + " to filter because it references an un-filterable metric '" + attributeInfo.name + "' which is most likely rolled up.");
        }
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        if (value instanceof Range)
            value = value.start;
        var druidFilter = {
            type: "selector",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            value: value
        };
        if (extractionFn) {
            druidFilter.extractionFn = extractionFn;
            if (this.versionBefore('0.9.1'))
                druidFilter.type = "extraction";
            if (this.versionBefore('0.9.0') && druidFilter.value === null)
                druidFilter.value = '';
        }
        return druidFilter;
    };
    DruidFilterBuilder.prototype.makeInFilter = function (ex, valueSet) {
        var _this = this;
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var elements = valueSet.elements;
        if (elements.length < 2 ||
            (this.versionBefore('0.9.1') && extractionFn) ||
            this.versionBefore('0.9.0')) {
            var fields = elements.map(function (value) {
                return _this.makeSelectorFilter(ex, value);
            });
            return { type: "or", fields: fields };
        }
        var inFilter = {
            type: 'in',
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            values: elements
        };
        if (extractionFn)
            inFilter.extractionFn = extractionFn;
        return inFilter;
    };
    DruidFilterBuilder.prototype.makeBoundFilter = function (ex, range) {
        var r0 = range.start;
        var r1 = range.end;
        var bounds = range.bounds;
        if (this.versionBefore('0.9.0')) {
            return this.makeJavaScriptFilter(ex.overlap(range));
        }
        if (this.versionBefore('0.9.2') && (r0 < 0 || r1 < 0)) {
            return this.makeJavaScriptFilter(ex.overlap(range));
        }
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (this.versionBefore('0.9.1') && extractionFn) {
            return this.makeJavaScriptFilter(ex.overlap(range));
        }
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var boundFilter = {
            type: "bound",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo)
        };
        if (extractionFn)
            boundFilter.extractionFn = extractionFn;
        if (range instanceof NumberRange) {
            if (this.versionBefore('0.9.2')) {
                boundFilter.alphaNumeric = true;
            }
            else {
                boundFilter.ordering = 'numeric';
            }
        }
        if (r0 != null) {
            boundFilter.lower = isDate(r0) ? r0.toISOString() : r0;
            if (bounds[0] === '(')
                boundFilter.lowerStrict = true;
        }
        if (r1 != null) {
            boundFilter.upper = isDate(r1) ? r1.toISOString() : r1;
            if (bounds[1] === ')')
                boundFilter.upperStrict = true;
        }
        return boundFilter;
    };
    DruidFilterBuilder.prototype.makeIntervalFilter = function (ex, range) {
        if (this.versionBefore('0.9.2')) {
            throw new Error("Can not filter " + ex + " on " + JSON.stringify(range));
        }
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var interval = this.valueToIntervals(range);
        return {
            type: "interval",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            intervals: Array.isArray(interval) ? interval : [interval]
        };
    };
    DruidFilterBuilder.prototype.makeRegexFilter = function (ex, regex) {
        var attributeInfo = this.getSingleReferenceAttributeInfo(ex);
        var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(ex);
        if (this.versionBefore('0.9.1') && extractionFn) {
            return this.makeExtractionFilter(ex.match(regex));
        }
        if (extractionFn)
            this.checkFilterExtractability(attributeInfo);
        var regexFilter = {
            type: "regex",
            dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
            pattern: regex
        };
        if (extractionFn)
            regexFilter.extractionFn = extractionFn;
        return regexFilter;
    };
    DruidFilterBuilder.prototype.makeContainsFilter = function (lhs, rhs, compare) {
        if (rhs instanceof LiteralExpression) {
            var attributeInfo = this.getSingleReferenceAttributeInfo(lhs);
            var extractionFn = new DruidExtractionFnBuilder(this).expressionToExtractionFn(lhs);
            if (extractionFn)
                this.checkFilterExtractability(attributeInfo);
            if (this.versionBefore('0.9.0')) {
                if (compare === ContainsExpression.IGNORE_CASE) {
                    return {
                        type: "search",
                        dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
                        query: {
                            type: "insensitive_contains",
                            value: rhs.value
                        }
                    };
                }
                else {
                    return this.makeJavaScriptFilter(lhs.contains(rhs, compare));
                }
            }
            if (this.versionBefore('0.9.1') && extractionFn) {
                return this.makeExtractionFilter(lhs.contains(rhs, compare));
            }
            var searchFilter = {
                type: "search",
                dimension: this.getDimensionNameForAttributeInfo(attributeInfo),
                query: {
                    type: "contains",
                    value: rhs.value,
                    caseSensitive: compare === ContainsExpression.NORMAL
                }
            };
            if (extractionFn)
                searchFilter.extractionFn = extractionFn;
            return searchFilter;
        }
        else {
            return this.makeJavaScriptFilter(lhs.contains(rhs, compare));
        }
    };
    DruidFilterBuilder.prototype.getSingleReferenceAttributeInfo = function (ex) {
        var freeReferences = ex.getFreeReferences();
        if (freeReferences.length !== 1)
            throw new Error("can not translate multi reference expression " + ex + " to Druid");
        var referenceName = freeReferences[0];
        return this.getAttributesInfo(referenceName);
    };
    DruidFilterBuilder.prototype.getDimensionNameForAttributeInfo = function (attributeInfo) {
        return attributeInfo.name === this.timeAttribute ? DruidFilterBuilder.TIME_ATTRIBUTE : attributeInfo.name;
    };
    DruidFilterBuilder.prototype.versionBefore = function (neededVersion) {
        var version = this.version;
        return version && External.versionLessThan(version, neededVersion);
    };
    DruidFilterBuilder.prototype.getAttributesInfo = function (attributeName) {
        return NamedArray.get(this.rawAttributes, attributeName);
    };
    DruidFilterBuilder.prototype.isTimeRef = function (ex) {
        return ex instanceof RefExpression && ex.name === this.timeAttribute;
    };
    DruidFilterBuilder.TIME_ATTRIBUTE = '__time';
    DruidFilterBuilder.TRUE_INTERVAL = "1000/3000";
    return DruidFilterBuilder;
}());
export { DruidFilterBuilder };
