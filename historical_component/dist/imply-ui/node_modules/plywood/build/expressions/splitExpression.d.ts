import { Datum, PlywoodValue } from '../datatypes/index';
import { SQLDialect } from '../dialect/baseDialect';
import { DatasetFullType } from '../types';
import { ChainableExpression, Expression, ExpressionJS, ExpressionTypeContext, ExpressionValue, Indexer, Splits, SubstitutionFn } from './baseExpression';
import { Aggregate } from './mixins/aggregate';
export declare class SplitExpression extends ChainableExpression implements Aggregate {
    static op: string;
    static fromJS(parameters: ExpressionJS): SplitExpression;
    keys: string[];
    splits: Splits;
    dataName: string;
    constructor(parameters: ExpressionValue);
    valueOf(): ExpressionValue;
    toJS(): ExpressionJS;
    equals(other: SplitExpression): boolean;
    changeSplits(splits: Splits): SplitExpression;
    numSplits(): number;
    isMultiSplit(): boolean;
    protected _toStringParameters(indent?: int): string[];
    updateTypeContext(typeContext: DatasetFullType): DatasetFullType;
    firstSplitName(): string;
    firstSplitExpression(): Expression;
    getArgumentExpressions(): Expression[];
    mapSplits<T>(fn: (name: string, expression?: Expression) => T): T[];
    mapSplitExpressions<T>(fn: (expression: Expression, name?: string) => T): Record<string, T>;
    calc(datum: Datum): PlywoodValue;
    getSQL(dialect: SQLDialect): string;
    getSelectSQL(dialect: SQLDialect): string[];
    getGroupBySQL(dialect: SQLDialect): string[];
    getShortGroupBySQL(): string[];
    fullyDefined(): boolean;
    simplify(): Expression;
    _substituteHelper(substitutionFn: SubstitutionFn, indexer: Indexer, depth: int, nestDiff: int, typeContext: DatasetFullType): ExpressionTypeContext;
    transformExpressions(fn: (expression: Expression, name?: string) => Expression): SplitExpression;
    filterFromDatum(datum: Datum): Expression;
    hasKey(key: string): boolean;
    isLinear(): boolean;
    maxBucketNumber(): number;
}
