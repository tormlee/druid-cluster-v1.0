"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hasOwnProp = require("has-own-prop");
var equality_1 = require("../equality/equality");
var named_array_1 = require("../named-array/named-array");
function firstUp(name) {
    return name[0].toUpperCase() + name.substr(1);
}
function isDefined(v) {
    return Array.isArray(v) ? v.length : v != null;
}
function noop(v) {
    return v;
}
exports.PropertyType = {
    DATE: 'date',
    ARRAY: 'array'
};
var BaseImmutable = (function () {
    function BaseImmutable(value) {
        var properties = this.ownProperties();
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            var propertyName = property.name;
            var propertyType = hasOwnProp(property, 'isDate') ? exports.PropertyType.DATE : property.type;
            var pv = value[propertyName];
            if (pv == null) {
                if (propertyType === exports.PropertyType.ARRAY) {
                    this[propertyName] = [];
                    continue;
                }
                if (!hasOwnProp(property, 'defaultValue')) {
                    throw new Error(this.constructor.name + "." + propertyName + " must be defined");
                }
            }
            else {
                var possibleValues = property.possibleValues;
                if (possibleValues && possibleValues.indexOf(pv) === -1) {
                    throw new Error(this.constructor.name + "." + propertyName + " can not have value '" + pv + "' must be one of [" + possibleValues.join(', ') + "]");
                }
                if (property.type === exports.PropertyType.DATE) {
                    if (isNaN(pv)) {
                        throw new Error(this.constructor.name + "." + propertyName + " must be a Date");
                    }
                }
                var validate = property.validate;
                if (validate) {
                    var validators = Array.isArray(validate) ? validate : [validate];
                    try {
                        for (var _a = 0, validators_1 = validators; _a < validators_1.length; _a++) {
                            var validator = validators_1[_a];
                            validator(pv);
                        }
                    }
                    catch (e) {
                        throw new Error(this.constructor.name + "." + propertyName + " " + e.message);
                    }
                }
            }
            this[propertyName] = pv;
        }
    }
    BaseImmutable.jsToValue = function (properties, js, backCompats, context) {
        if (properties == null) {
            throw new Error("JS is not defined");
        }
        if (Array.isArray(backCompats)) {
            var jsCopied = false;
            for (var _i = 0, backCompats_1 = backCompats; _i < backCompats_1.length; _i++) {
                var backCompat = backCompats_1[_i];
                if (backCompat.condition(js)) {
                    if (!jsCopied) {
                        js = JSON.parse(JSON.stringify(js));
                        jsCopied = true;
                    }
                    backCompat.action(js);
                }
            }
        }
        var value = {};
        var _loop_1 = function (property) {
            var propertyName = property.name;
            var contextTransform = property.contextTransform || noop;
            var pv = js[propertyName];
            if (pv != null) {
                if (property.type === exports.PropertyType.DATE) {
                    pv = new Date(pv);
                }
                else if (property.immutableClass) {
                    pv = property.immutableClass.fromJS(pv, contextTransform(context));
                }
                else if (property.immutableClassArray) {
                    if (!Array.isArray(pv))
                        throw new Error("expected " + propertyName + " to be an array");
                    var propertyImmutableClassArray_1 = property.immutableClassArray;
                    pv = pv.map(function (v) { return propertyImmutableClassArray_1.fromJS(v, contextTransform(context)); });
                }
            }
            value[propertyName] = pv;
        };
        for (var _a = 0, properties_2 = properties; _a < properties_2.length; _a++) {
            var property = properties_2[_a];
            _loop_1(property);
        }
        return value;
    };
    BaseImmutable.finalize = function (ClassFn) {
        var proto = ClassFn.prototype;
        ClassFn.PROPERTIES.forEach(function (property) {
            var propertyName = property.name;
            var defaultValue = property.defaultValue;
            var upped = firstUp(property.name);
            var getUpped = 'get' + upped;
            var changeUpped = 'change' + upped;
            proto[getUpped] = proto[getUpped] || function () {
                var pv = this[propertyName];
                return pv != null ? pv : defaultValue;
            };
            proto[changeUpped] = proto[changeUpped] || function (newValue) {
                var value = this.valueOf();
                value[propertyName] = newValue;
                return new this.constructor(value);
            };
        });
    };
    BaseImmutable.prototype.ownProperties = function () {
        return this.constructor.PROPERTIES;
    };
    BaseImmutable.prototype.findOwnProperty = function (propName) {
        var properties = this.ownProperties();
        return named_array_1.NamedArray.findByName(properties, propName);
    };
    BaseImmutable.prototype.hasProperty = function (propName) {
        return this.findOwnProperty(propName) !== null;
    };
    BaseImmutable.prototype.valueOf = function () {
        var value = {};
        var properties = this.ownProperties();
        for (var _i = 0, properties_3 = properties; _i < properties_3.length; _i++) {
            var property = properties_3[_i];
            var propertyName = property.name;
            value[propertyName] = this[propertyName];
        }
        return value;
    };
    BaseImmutable.prototype.toJS = function () {
        var js = {};
        var properties = this.ownProperties();
        for (var _i = 0, properties_4 = properties; _i < properties_4.length; _i++) {
            var property = properties_4[_i];
            var propertyName = property.name;
            var pv = this[propertyName];
            if (isDefined(pv) || property.preserveUndefined) {
                if (typeof property.toJS === 'function') {
                    pv = property.toJS(pv);
                }
                else if (property.immutableClass) {
                    pv = pv.toJS();
                }
                else if (property.immutableClassArray) {
                    pv = pv.map(function (v) { return v.toJS(); });
                }
                js[propertyName] = pv;
            }
        }
        return js;
    };
    BaseImmutable.prototype.toJSON = function () {
        return this.toJS();
    };
    BaseImmutable.prototype.toString = function () {
        var name = this.name;
        var extra = name === 'string' ? ": " + name : '';
        return "[ImmutableClass" + extra + "]";
    };
    BaseImmutable.prototype.equals = function (other) {
        if (!other)
            return false;
        if (this === other)
            return true;
        if (!(other instanceof this.constructor))
            return false;
        var properties = this.ownProperties();
        for (var _i = 0, properties_5 = properties; _i < properties_5.length; _i++) {
            var property = properties_5[_i];
            var propertyName = property.name;
            var equal = property.equal || equality_1.generalEqual;
            if (!equal(this[propertyName], other[propertyName]))
                return false;
        }
        return true;
    };
    BaseImmutable.prototype.get = function (propName) {
        var getter = this['get' + firstUp(propName)];
        if (!getter)
            throw new Error("can not find prop " + propName);
        return getter.call(this);
    };
    BaseImmutable.prototype.change = function (propName, newValue) {
        var changer = this['change' + firstUp(propName)];
        if (!changer)
            throw new Error("can not find prop " + propName);
        return changer.call(this, newValue);
    };
    BaseImmutable.prototype.changeMany = function (properties) {
        if (!properties)
            throw new TypeError('Invalid properties object');
        var o = this;
        for (var propName in properties) {
            if (!this.hasProperty(propName))
                throw new Error('Unknown property: ' + propName);
            o = o.change(propName, properties[propName]);
        }
        return o;
    };
    BaseImmutable.prototype.deepChange = function (propName, newValue) {
        var _this = this;
        var bits = propName.split('.');
        var lastObject = newValue;
        var currentObject;
        var getLastObject = function () {
            var o = _this;
            for (var i = 0; i < bits.length; i++) {
                o = o[bits[i]];
            }
            return o;
        };
        while (bits.length) {
            var bit = bits.pop();
            currentObject = getLastObject();
            if (currentObject.change instanceof Function) {
                lastObject = currentObject.change(bit, lastObject);
            }
            else {
                var message = 'Can\'t find \`change()\` method on ' + currentObject.constructor.name;
                throw new Error(message);
            }
        }
        return lastObject;
    };
    BaseImmutable.prototype.deepGet = function (propName) {
        var value = this;
        var bits = propName.split('.');
        var bit;
        while (bit = bits.shift()) {
            var specializedGetterName = "get" + firstUp(bit);
            var specializedGetter = value[specializedGetterName];
            value = specializedGetter ? specializedGetter.call(value)
                : value.get ? value.get(bit)
                    : value[bit];
        }
        return value;
    };
    return BaseImmutable;
}());
BaseImmutable.ensure = {
    number: function (n) {
        if (isNaN(n) || typeof n !== 'number')
            throw new Error("must be a number");
    },
    positive: function (n) {
        if (n < 0)
            throw new Error('must be positive');
    },
    nonNegative: function (n) {
        if (n < 0)
            throw new Error('must be non negative');
    }
};
exports.BaseImmutable = BaseImmutable;
