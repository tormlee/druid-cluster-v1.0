export interface Validator {
    (x: any): void;
}
export interface ImmutableLike {
    fromJS: (js: any, context?: any) => any;
}
export declare type PropertyType = 'date' | 'array';
export declare const PropertyType: {
    DATE: PropertyType;
    ARRAY: PropertyType;
};
export interface Property {
    name: string;
    defaultValue?: any;
    possibleValues?: any[];
    validate?: Validator | Validator[];
    type?: PropertyType;
    immutableClass?: ImmutableLike;
    immutableClassArray?: ImmutableLike;
    equal?: (a: any, b: any) => boolean;
    toJS?: (v: any) => any;
    contextTransform?: (context: {
        [key: string]: any;
    }) => {
        [key: string]: any;
    };
    preserveUndefined?: boolean;
}
export interface ClassFnType {
    PROPERTIES: Property[];
    fromJS(properties: any, context?: any): any;
    new (properties: any): any;
}
export interface ImmutableInstanceType<ValueType, JSType> {
    valueOf(): ValueType;
    toJS(): JSType;
    toJSON(): JSType;
    toString(): string;
    equals(other: ImmutableInstanceType<ValueType, JSType>): boolean;
}
export interface BackCompat {
    condition: (js: any) => boolean;
    action: (js: any) => void;
}
export declare abstract class BaseImmutable<ValueType, JSType> implements ImmutableInstanceType<ValueType, JSType> {
    static jsToValue(properties: Property[], js: any, backCompats?: BackCompat[], context?: {
        [key: string]: any;
    }): any;
    static finalize(ClassFn: ClassFnType): void;
    static ensure: {
        number: (n: any) => void;
        positive: (n: any) => void;
        nonNegative: (n: any) => void;
    };
    constructor(value: ValueType);
    ownProperties(): Property[];
    findOwnProperty(propName: string): Property | null;
    hasProperty(propName: string): boolean;
    valueOf(): ValueType;
    toJS(): JSType;
    toJSON(): JSType;
    toString(): string;
    equals(other: BaseImmutable<ValueType, JSType>): boolean;
    get(propName: string): any;
    change(propName: string, newValue: any): this;
    changeMany(properties: Record<string, any>): this;
    deepChange(propName: string, newValue: any): this;
    deepGet(propName: string): any;
}
