"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var simple_array_1 = require("../simple-array/simple-array");
var keyed_array_1 = require("../keyed-array/keyed-array");
var equality_1 = require("../equality/equality");
function getName(thing) {
    return thing.name;
}
function noop() { }
var Diff = (function () {
    function Diff(before, after) {
        if (!before && !after)
            throw new Error('must have either a before or an after');
        if (before && after && before.name !== after.name)
            throw new Error('before and after name must match');
        this.before = before;
        this.after = after;
    }
    Diff.inflateFromJS = function (Class, diffJS) {
        var before = null;
        var after = null;
        if (diffJS.before)
            before = Class.fromJS(diffJS.before);
        if (diffJS.after)
            after = Class.fromJS(diffJS.after);
        return new Diff(before, after);
    };
    Diff.inflateFromJSs = function (Class, diffJSs) {
        if (!Array.isArray(diffJSs))
            throw new Error('diffs must be an array');
        return diffJSs.map(function (diffJS) { return Diff.inflateFromJS(Class, diffJS); });
    };
    Diff.prototype.toJS = function () {
        var js = {};
        if (this.before)
            js.before = this.before;
        if (this.after)
            js.after = this.after;
        return js;
    };
    Diff.prototype.toJSON = function () {
        return this.toJS();
    };
    Diff.prototype.getName = function () {
        return this.before ? this.before.name : this.after.name;
    };
    return Diff;
}());
exports.Diff = Diff;
var KEYED_ARRAY = keyed_array_1.KeyedArray.withKey("name");
var NamedArray = (function () {
    function NamedArray() {
    }
    NamedArray.isValid = function (array) {
        return KEYED_ARRAY.isValid(array);
    };
    NamedArray.checkValid = function (array) {
        return KEYED_ARRAY.checkValid(array);
    };
    NamedArray.get = function (array, name) {
        return KEYED_ARRAY.get(array, name);
    };
    NamedArray.containsByName = function (array, name) {
        return simple_array_1.SimpleArray.contains(array, function (x) { return x.name === name; });
    };
    NamedArray.findByNameCI = function (array, name) {
        var lowerName = name.toLowerCase();
        return simple_array_1.SimpleArray.find(array, function (x) { return x.name.toLowerCase() === lowerName; });
    };
    NamedArray.findByName = function (array, name) {
        return NamedArray.get(array, name);
    };
    NamedArray.findIndexByName = function (array, name) {
        return simple_array_1.SimpleArray.findIndex(array, function (x) { return x.name === name; });
    };
    NamedArray.overrideByName = function (things, thingOverride) {
        return KEYED_ARRAY.overrideByKey(things, thingOverride);
    };
    NamedArray.overridesByName = function (things, thingOverrides) {
        return KEYED_ARRAY.overridesByKey(things, thingOverrides);
    };
    NamedArray.deleteByName = function (array, name) {
        return KEYED_ARRAY.deleteByKey(array, name);
    };
    NamedArray.synchronize = function (oldThings, newThings, updatedOptions) {
        var key = updatedOptions.key || getName;
        var equals = updatedOptions.equals || equality_1.immutableEqual;
        var onEnter = updatedOptions.onEnter || noop;
        var onUpdate = updatedOptions.onUpdate || noop;
        var onExit = updatedOptions.onExit || noop;
        var initialByKey = Object.create(null);
        for (var i = 0; i < oldThings.length; i++) {
            var initialThing = oldThings[i];
            var initialThingKey = key(initialThing);
            if (initialByKey[initialThingKey])
                throw new Error("duplicate key '" + initialThingKey + "'");
            initialByKey[initialThingKey] = initialThing;
        }
        for (var j = 0; j < newThings.length; j++) {
            var newThing = newThings[j];
            var newThingKey = key(newThing);
            var oldThing = initialByKey[newThingKey];
            if (oldThing) {
                if (!equals(newThing, oldThing)) {
                    onUpdate(newThing, oldThing);
                }
                delete initialByKey[newThingKey];
            }
            else {
                onEnter(newThing);
            }
        }
        for (var k in initialByKey) {
            if (!initialByKey[k])
                continue;
            onExit(initialByKey[k]);
        }
    };
    NamedArray.computeDiffs = function (oldThings, newThings) {
        var dataCubeDiffs = [];
        NamedArray.synchronize(oldThings, newThings, {
            onExit: function (oldDataCube) {
                dataCubeDiffs.push(new Diff(oldDataCube, null));
            },
            onUpdate: function (newDataCube, oldDataCube) {
                dataCubeDiffs.push(new Diff(oldDataCube, newDataCube));
            },
            onEnter: function (newDataCube) {
                dataCubeDiffs.push(new Diff(null, newDataCube));
            }
        });
        return dataCubeDiffs;
    };
    return NamedArray;
}());
exports.NamedArray = NamedArray;
