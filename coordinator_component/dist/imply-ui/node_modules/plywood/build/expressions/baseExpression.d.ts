import { Duration, Timezone } from 'chronoshift';
import { Instance } from 'immutable-class';
import { ReadableStream } from 'readable-stream';
import { ComputeFn, Dataset, DatasetExternalAlterations, Datum, PlywoodValue } from '../datatypes/index';
import { SQLDialect } from '../dialect/baseDialect';
import { External, ExternalJS } from '../external/baseExternal';
import { DatasetFullType, Environment, PlyType, PlyTypeSimple, PlyTypeSingleValue } from '../types';
import { AbsoluteExpression } from './absoluteExpression';
import { AddExpression } from './addExpression';
import { AndExpression } from './andExpression';
import { ApplyExpression } from './applyExpression';
import { AverageExpression } from './averageExpression';
import { CardinalityExpression } from './cardinalityExpression';
import { CastExpression } from './castExpression';
import { CollectExpression } from './collectExpression';
import { ConcatExpression } from './concatExpression';
import { ContainsExpression } from './containsExpression';
import { CountDistinctExpression } from './countDistinctExpression';
import { CountExpression } from './countExpression';
import { CustomAggregateExpression } from './customAggregateExpression';
import { CustomTransformExpression } from './customTransformExpression';
import { DivideExpression } from './divideExpression';
import { ExternalExpression } from './externalExpression';
import { ExtractExpression } from './extractExpression';
import { FallbackExpression } from './fallbackExpression';
import { FilterExpression } from './filterExpression';
import { GreaterThanExpression } from './greaterThanExpression';
import { GreaterThanOrEqualExpression } from './greaterThanOrEqualExpression';
import { IndexOfExpression } from './indexOfExpression';
import { InExpression } from './inExpression';
import { IsExpression } from './isExpression';
import { JoinExpression } from './joinExpression';
import { LengthExpression } from './lengthExpression';
import { LessThanExpression } from './lessThanExpression';
import { LessThanOrEqualExpression } from './lessThanOrEqualExpression';
import { LimitExpression } from './limitExpression';
import { LiteralExpression } from './literalExpression';
import { LookupExpression } from './lookupExpression';
import { MatchExpression } from './matchExpression';
import { MaxExpression } from './maxExpression';
import { MinExpression } from './minExpression';
import { MultiplyExpression } from './multiplyExpression';
import { NotExpression } from './notExpression';
import { NumberBucketExpression } from './numberBucketExpression';
import { OrExpression } from './orExpression';
import { OverlapExpression } from './overlapExpression';
import { PowerExpression } from './powerExpression';
import { QuantileExpression } from './quantileExpression';
import { RefExpression } from './refExpression';
import { SelectExpression } from './selectExpression';
import { Direction, SortExpression } from './sortExpression';
import { SplitExpression } from './splitExpression';
import { SubstrExpression } from './substrExpression';
import { SubtractExpression } from './subtractExpression';
import { SumExpression } from './sumExpression';
import { ThenExpression } from './thenExpression';
import { TimeBucketExpression } from './timeBucketExpression';
import { TimeFloorExpression } from './timeFloorExpression';
import { TimePartExpression } from './timePartExpression';
import { TimeRangeExpression } from './timeRangeExpression';
import { TimeShiftExpression } from './timeShiftExpression';
import { TransformCaseExpression } from './transformCaseExpression';
export interface ComputeOptions extends Environment {
    rawQueries?: any[];
    maxQueries?: number;
    maxRows?: number;
    maxComputeCycles?: number;
}
export interface AlterationFillerPromise {
    (external: External, terminal: boolean): Promise<any>;
}
export interface ExpressionExternalAlterationSimple {
    external: External;
    terminal?: boolean;
    result?: any;
}
export declare type ExpressionExternalAlteration = Record<string, ExpressionExternalAlterationSimple | DatasetExternalAlterations>;
export interface BooleanExpressionIterator {
    (ex: Expression, index?: int, depth?: int, nestDiff?: int): boolean;
}
export interface VoidExpressionIterator {
    (ex: Expression, index?: int, depth?: int, nestDiff?: int): void;
}
export interface SubstitutionFn {
    (ex: Expression, index?: int, depth?: int, nestDiff?: int, typeContext?: DatasetFullType): Expression;
}
export interface ExpressionMatchFn {
    (ex: Expression): boolean;
}
export interface DatasetBreakdown {
    singleDatasetActions: ApplyExpression[];
    combineExpression: Expression;
}
export interface Indexer {
    index: int;
}
export interface ExpressionTypeContext {
    expression: Expression;
    typeContext: DatasetFullType;
}
export declare type Alterations = Record<string, Expression>;
export interface SQLParse {
    verb: string;
    rewrite?: string;
    expression?: Expression;
    table?: string;
    database?: string;
    rest?: string;
}
export interface Splits {
    [name: string]: Expression;
}
export interface SplitsJS {
    [name: string]: ExpressionJS;
}
export declare type CaseType = 'upperCase' | 'lowerCase';
export interface ExpressionValue {
    op?: string;
    type?: PlyType;
    simple?: boolean;
    operand?: Expression;
    value?: any;
    name?: string;
    nest?: int;
    external?: External;
    expression?: Expression;
    actions?: any[];
    ignoreCase?: boolean;
    dataName?: string;
    splits?: Splits;
    direction?: Direction;
    size?: number;
    offset?: number;
    duration?: Duration;
    timezone?: Timezone;
    part?: string;
    step?: number;
    position?: int;
    len?: int;
    regexp?: string;
    custom?: string;
    compare?: string;
    lookupFn?: string;
    attributes?: string[];
    transformType?: CaseType;
    outputType?: PlyTypeSimple;
    tuning?: string;
}
export interface ExpressionJS {
    op?: string;
    type?: PlyType;
    value?: any;
    operand?: ExpressionJS;
    name?: string;
    nest?: int;
    external?: ExternalJS;
    expression?: ExpressionJS;
    action?: any;
    actions?: any[];
    ignoreCase?: boolean;
    dataName?: string;
    splits?: SplitsJS;
    direction?: Direction;
    size?: number;
    offset?: number;
    duration?: string;
    timezone?: string;
    part?: string;
    step?: number;
    position?: int;
    len?: int;
    regexp?: string;
    custom?: string;
    compare?: string;
    lookupFn?: string;
    attributes?: string[];
    transformType?: CaseType;
    outputType?: PlyTypeSimple;
    tuning?: string;
}
export interface ExtractAndRest {
    extract: Expression;
    rest: Expression;
}
export declare type IfNotFound = "throw" | "leave" | "null";
export declare function ply(dataset?: Dataset): LiteralExpression;
export declare function $(name: string, nest?: number, type?: PlyType): RefExpression;
export declare function $(name: string, type?: PlyType): RefExpression;
export declare function i$(name: string, nest?: number, type?: PlyType): RefExpression;
export declare function r(value: any): LiteralExpression;
export declare function toJS(thing: any): any;
export interface PEGParserOptions {
    cache?: boolean;
    allowedStartRules?: string;
    output?: string;
    optimize?: string;
    plugins?: any;
    [key: string]: any;
}
export interface PEGParser {
    parse: (str: string, options?: PEGParserOptions) => any;
}
export declare abstract class Expression implements Instance<ExpressionValue, ExpressionJS> {
    static NULL: LiteralExpression;
    static ZERO: LiteralExpression;
    static ONE: LiteralExpression;
    static FALSE: LiteralExpression;
    static TRUE: LiteralExpression;
    static EMPTY_STRING: LiteralExpression;
    static EMPTY_SET: LiteralExpression;
    static _: RefExpression;
    static expressionParser: PEGParser;
    static plyqlParser: PEGParser;
    static defaultParserTimezone: Timezone;
    static isExpression(candidate: any): candidate is Expression;
    static expressionLookupFromJS(expressionJSs: Record<string, ExpressionJS>): Record<string, Expression>;
    static expressionLookupToJS(expressions: Record<string, Expression>): Record<string, ExpressionJS>;
    static parse(str: string, timezone?: Timezone): Expression;
    static parseSQL(str: string, timezone?: Timezone): SQLParse;
    static fromJSLoose(param: any): Expression;
    static jsNullSafetyUnary(inputJS: string, ifNotNull: (str: string) => string): string;
    static jsNullSafetyBinary(lhs: string, rhs: string, combine: (lhs: string, rhs: string) => string, lhsCantBeNull?: boolean, rhsCantBeNull?: boolean): string;
    static parseTuning(tuning: string | null): Record<string, string>;
    static and(expressions: Expression[]): Expression;
    static or(expressions: Expression[]): Expression;
    static add(expressions: Expression[]): Expression;
    static subtract(expressions: Expression[]): Expression;
    static multiply(expressions: Expression[]): Expression;
    static power(expressions: Expression[]): Expression;
    static concat(expressions: Expression[]): Expression;
    static classMap: Record<string, typeof Expression>;
    static register(ex: typeof Expression): void;
    static getConstructorFor(op: string): typeof Expression;
    static applyMixins(derivedCtor: any, baseCtors: any[]): void;
    static jsToValue(js: ExpressionJS): ExpressionValue;
    static fromJS(expressionJS: ExpressionJS): Expression;
    static fromValue(parameters: ExpressionValue): Expression;
    op: string;
    type: PlyType;
    simple: boolean;
    constructor(parameters: ExpressionValue, dummy?: any);
    protected _ensureOp(op: string): void;
    valueOf(): ExpressionValue;
    toJS(): ExpressionJS;
    toJSON(): ExpressionJS;
    abstract toString(indent?: int): string;
    equals(other: Expression): boolean;
    canHaveType(wantedType: string): boolean;
    expressionCount(): int;
    isOp(op: string): boolean;
    markSimple(): this;
    containsOp(op: string): boolean;
    hasExternal(): boolean;
    getBaseExternals(): External[];
    getRawExternals(): External[];
    getReadyExternals(): ExpressionExternalAlteration;
    applyReadyExternals(alterations: ExpressionExternalAlteration): Expression;
    private _headExternal();
    getHeadOperand(): Expression;
    getFreeReferences(): string[];
    getFreeReferenceIndexes(): number[];
    incrementNesting(by?: int): Expression;
    simplify(): Expression;
    every(iter: BooleanExpressionIterator, thisArg?: any): boolean;
    _everyHelper(iter: BooleanExpressionIterator, thisArg: any, indexer: Indexer, depth: int, nestDiff: int): boolean;
    some(iter: BooleanExpressionIterator, thisArg?: any): boolean;
    forEach(iter: VoidExpressionIterator, thisArg?: any): void;
    substitute(substitutionFn: SubstitutionFn, typeContext?: DatasetFullType): Expression;
    _substituteHelper(substitutionFn: SubstitutionFn, indexer: Indexer, depth: int, nestDiff: int, typeContext: DatasetFullType): ExpressionTypeContext;
    abstract getFn(): ComputeFn;
    fullyDefined(): boolean;
    abstract calc(datum: Datum): PlywoodValue;
    abstract getJS(datumVar: string): string;
    getJSFn(datumVar?: string): string;
    abstract getSQL(dialect: SQLDialect): string;
    extractFromAnd(matchFn: ExpressionMatchFn): ExtractAndRest;
    breakdownByDataset(tempNamePrefix?: string): DatasetBreakdown;
    getLiteralValue(): any;
    upgradeToType(targetType: PlyType): Expression;
    performAction(action: Expression): Expression;
    performActions(actions: Expression[]): Expression;
    private _mkChain<T>(ExpressionClass, exs);
    add(...exs: any[]): AddExpression;
    subtract(...exs: any[]): SubtractExpression;
    negate(): SubtractExpression;
    multiply(...exs: any[]): MultiplyExpression;
    divide(...exs: any[]): DivideExpression;
    reciprocate(): DivideExpression;
    sqrt(): PowerExpression;
    power(...exs: any[]): PowerExpression;
    then(ex: any): ThenExpression;
    fallback(ex: any): FallbackExpression;
    is(ex: any): IsExpression;
    isnt(ex: any): NotExpression;
    lessThan(ex: any): LessThanExpression;
    lessThanOrEqual(ex: any): LessThanOrEqualExpression;
    greaterThan(ex: any): GreaterThanExpression;
    greaterThanOrEqual(ex: any): GreaterThanOrEqualExpression;
    contains(ex: any, compare?: string): ContainsExpression;
    match(re: string): MatchExpression;
    in(ex: any): InExpression;
    overlap(ex: any, snd?: Date | number | string): OverlapExpression;
    not(): NotExpression;
    and(...exs: any[]): AndExpression;
    or(...exs: any[]): OrExpression;
    substr(position: number, len: number): SubstrExpression;
    extract(re: string): ExtractExpression;
    concat(...exs: any[]): ConcatExpression;
    lookup(lookupFn: string): LookupExpression;
    indexOf(ex: any): IndexOfExpression;
    transformCase(transformType: CaseType): TransformCaseExpression;
    customTransform(custom: string, outputType?: PlyTypeSingleValue): CustomTransformExpression;
    numberBucket(size: number, offset?: number): NumberBucketExpression;
    absolute(): AbsoluteExpression;
    length(): LengthExpression;
    timeBucket(duration: any, timezone?: any): TimeBucketExpression;
    timeFloor(duration: any, timezone?: any): TimeFloorExpression;
    timeShift(duration: any, step?: number, timezone?: any): TimeShiftExpression;
    timeRange(duration: any, step?: number, timezone?: any): TimeRangeExpression;
    timePart(part: string, timezone?: any): TimePartExpression;
    cast(outputType: PlyType): CastExpression;
    cardinality(): CardinalityExpression;
    filter(ex: any): FilterExpression;
    split(splits: any, dataName?: string): SplitExpression;
    split(ex: any, name: string, dataName?: string): SplitExpression;
    apply(name: string, ex: any): ApplyExpression;
    sort(ex: any, direction?: Direction): SortExpression;
    limit(value: number): LimitExpression;
    select(attributes: string[]): SelectExpression;
    count(): CountExpression;
    sum(ex: any): SumExpression;
    min(ex: any): MinExpression;
    max(ex: any): MaxExpression;
    average(ex: any): AverageExpression;
    countDistinct(ex: any): CountDistinctExpression;
    quantile(ex: any, value: number, tuning?: string): QuantileExpression;
    collect(ex: any): CollectExpression;
    customAggregate(custom: string): CustomAggregateExpression;
    join(ex: any): JoinExpression;
    needsEnvironment(): boolean;
    defineEnvironment(environment: Environment): Expression;
    referenceCheck(context: Datum): Expression;
    definedInTypeContext(typeContext: DatasetFullType): boolean;
    referenceCheckInTypeContext(typeContext: DatasetFullType): Expression;
    changeInTypeContext(typeContext: DatasetFullType): Expression;
    updateTypeContext(typeContext: DatasetFullType, extra?: any): DatasetFullType;
    updateTypeContextIfNeeded(typeContext: DatasetFullType | null, extra?: any): DatasetFullType | null;
    resolve(context: Datum, ifNotFound?: IfNotFound): Expression;
    resolveWithExpressions(expressions: Record<string, Expression>, ifNotFound?: IfNotFound): Expression;
    resolved(): boolean;
    resolvedWithoutExternals(): boolean;
    noRefs(): boolean;
    isAggregate(): boolean;
    decomposeAverage(countEx?: Expression): Expression;
    distribute(): Expression;
    maxPossibleSplitValues(): number;
    private _initialPrepare(context, environment);
    simulate(context?: Datum, options?: ComputeOptions): PlywoodValue;
    simulateQueryPlan(context?: Datum, options?: ComputeOptions): any[][];
    private _computeResolvedSimulate(options, simulatedQueryGroups);
    compute(context?: Datum, options?: ComputeOptions): Promise<PlywoodValue>;
    computeStream(context?: Datum, options?: ComputeOptions): ReadableStream;
    private _computeResolved(options);
}
export declare abstract class ChainableExpression extends Expression {
    static jsToValue(js: ExpressionJS): ExpressionValue;
    operand: Expression;
    constructor(value: ExpressionValue, dummy?: any);
    protected _checkTypeAgainstTypes(name: string, type: string, neededTypes: string[]): void;
    protected _checkOperandTypes(...neededTypes: string[]): void;
    protected _checkOperandTypesStrict(...neededTypes: string[]): void;
    protected _bumpOperandToTime(): void;
    valueOf(): ExpressionValue;
    toJS(): ExpressionJS;
    protected _toStringParameters(indent?: int): string[];
    toString(indent?: int): string;
    equals(other: ChainableExpression): boolean;
    changeOperand(operand: Expression): this;
    swapWithOperand(): ChainableExpression;
    getAction(): Expression;
    getHeadOperand(): Expression;
    getArgumentExpressions(): Expression[];
    expressionCount(): int;
    argumentsResolved(): boolean;
    argumentsResolvedWithoutExternals(): boolean;
    getFn(): ComputeFn;
    protected _calcChainableHelper(operandValue: any): PlywoodValue;
    fullyDefined(): boolean;
    calc(datum: Datum): PlywoodValue;
    protected _getJSChainableHelper(operandJS: string): string;
    getJS(datumVar: string): string;
    protected _getSQLChainableHelper(dialect: SQLDialect, operandSQL: string): string;
    getSQL(dialect: SQLDialect): string;
    pushIntoExternal(): ExternalExpression | null;
    protected specialSimplify(): Expression;
    simplify(): Expression;
    isNester(): boolean;
    _everyHelper(iter: BooleanExpressionIterator, thisArg: any, indexer: Indexer, depth: int, nestDiff: int): boolean;
    _substituteHelper(substitutionFn: SubstitutionFn, indexer: Indexer, depth: int, nestDiff: int, typeContext: DatasetFullType): ExpressionTypeContext;
}
export declare abstract class ChainableUnaryExpression extends ChainableExpression {
    static jsToValue(js: ExpressionJS): ExpressionValue;
    expression: Expression;
    constructor(value: ExpressionValue, dummy?: any);
    protected _checkExpressionTypes(...neededTypes: string[]): void;
    protected _checkExpressionTypesStrict(...neededTypes: string[]): void;
    protected _checkOperandExpressionTypesAlign(): void;
    protected _bumpOperandExpressionToTime(): void;
    valueOf(): ExpressionValue;
    toJS(): ExpressionJS;
    protected _toStringParameters(indent?: int): string[];
    toString(indent?: int): string;
    equals(other: ChainableUnaryExpression): boolean;
    changeExpression(expression: Expression): this;
    protected _calcChainableUnaryHelper(operandValue: any, expressionValue: any): PlywoodValue;
    fullyDefined(): boolean;
    calc(datum: Datum): PlywoodValue;
    protected _getJSChainableUnaryHelper(operandJS: string, expressionJS: string): string;
    getJS(datumVar: string): string;
    protected _getSQLChainableUnaryHelper(dialect: SQLDialect, operandSQL: string, expressionSQL: string): string;
    getSQL(dialect: SQLDialect): string;
    getExpressionList(): Expression[];
    isCommutative(): boolean;
    isAssociative(): boolean;
    associateLeft(): this | null;
    associateRightIfSimpler(): this | null;
    pushIntoExternal(): ExternalExpression | null;
    simplify(): Expression;
    getArgumentExpressions(): Expression[];
    _substituteHelper(substitutionFn: SubstitutionFn, indexer: Indexer, depth: int, nestDiff: int, typeContext: DatasetFullType): ExpressionTypeContext;
}
