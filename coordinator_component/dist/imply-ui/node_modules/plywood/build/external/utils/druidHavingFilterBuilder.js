import { AndExpression, IsExpression, LiteralExpression, NotExpression, OrExpression, OverlapExpression, RefExpression } from '../../expressions/index';
import { External } from '../baseExternal';
import { DruidFilterBuilder } from './druidFilterBuilder';
var DruidHavingFilterBuilder = (function () {
    function DruidHavingFilterBuilder(options) {
        this.version = options.version;
        this.attributes = options.attributes;
        this.customTransforms = options.customTransforms;
    }
    DruidHavingFilterBuilder.prototype.filterToHavingFilter = function (filter) {
        if (this.versionBefore('0.10.0')) {
            return this.filterToLegacyHavingFilter(filter);
        }
        else {
            return {
                type: 'filter',
                filter: new DruidFilterBuilder({
                    version: this.version,
                    rawAttributes: this.attributes,
                    timeAttribute: '***',
                    allowEternity: true,
                    customTransforms: this.customTransforms
                }).timelessFilterToFilter(filter, false)
            };
        }
    };
    DruidHavingFilterBuilder.prototype.filterToLegacyHavingFilter = function (filter) {
        var _this = this;
        if (filter instanceof LiteralExpression) {
            if (filter.value === true) {
                return null;
            }
            else {
                throw new Error("should never get here");
            }
        }
        else if (filter instanceof NotExpression) {
            return {
                type: 'not',
                havingSpec: this.filterToHavingFilter(filter.operand)
            };
        }
        else if (filter instanceof AndExpression) {
            return {
                type: 'and',
                havingSpecs: filter.getExpressionList().map(this.filterToHavingFilter, this)
            };
        }
        else if (filter instanceof OrExpression) {
            return {
                type: 'or',
                havingSpecs: filter.getExpressionList().map(this.filterToHavingFilter, this)
            };
        }
        else if (filter instanceof IsExpression) {
            var lhs_1 = filter.operand, rhs = filter.expression;
            if (lhs_1 instanceof RefExpression && rhs instanceof LiteralExpression) {
                var rhsType = rhs.type;
                if (rhsType === 'STRING' || rhsType === 'NUMBER') {
                    return {
                        type: "equalTo",
                        aggregation: lhs_1.name,
                        value: rhs.value
                    };
                }
                else if (rhsType === 'SET/STRING' || rhsType === 'SET/NUMBER') {
                    return {
                        type: "or",
                        havingSpecs: rhs.value.elements.map(function (value) {
                            return {
                                type: "equalTo",
                                aggregation: lhs_1.name,
                                value: value
                            };
                        })
                    };
                }
            }
            else {
                throw new Error("can not convert " + filter + " to Druid having filter");
            }
        }
        else if (filter instanceof OverlapExpression) {
            var lhs_2 = filter.operand, rhs = filter.expression;
            if (lhs_2 instanceof RefExpression && rhs instanceof LiteralExpression) {
                var rhsType = rhs.type;
                if (rhsType === 'SET/NUMBER_RANGE') {
                    return {
                        type: "or",
                        havingSpecs: rhs.value.elements.map(function (value) {
                            return _this.inToHavingFilter(lhs_2.name, value);
                        }, this)
                    };
                }
                else if (rhsType === 'NUMBER_RANGE') {
                    return this.inToHavingFilter(lhs_2.name, rhs.value);
                }
                else if (rhsType === 'TIME_RANGE') {
                    throw new Error("can not compute having filter on time");
                }
                else {
                    throw new Error("not supported " + rhsType);
                }
            }
            else {
                throw new Error("can not convert " + filter + " to Druid having filter");
            }
        }
        throw new Error("could not convert filter " + filter + " to Druid having filter");
    };
    DruidHavingFilterBuilder.prototype.makeHavingComparison = function (agg, op, value) {
        switch (op) {
            case '<':
                return { type: "lessThan", aggregation: agg, value: value };
            case '>':
                return { type: "greaterThan", aggregation: agg, value: value };
            case '<=':
                return { type: 'not', havingSpec: { type: "greaterThan", aggregation: agg, value: value } };
            case '>=':
                return { type: 'not', havingSpec: { type: "lessThan", aggregation: agg, value: value } };
            default:
                throw new Error("unknown op: " + op);
        }
    };
    DruidHavingFilterBuilder.prototype.inToHavingFilter = function (agg, range) {
        var havingSpecs = [];
        if (range.start !== null) {
            havingSpecs.push(this.makeHavingComparison(agg, (range.bounds[0] === '[' ? '>=' : '>'), range.start));
        }
        if (range.end !== null) {
            havingSpecs.push(this.makeHavingComparison(agg, (range.bounds[1] === ']' ? '<=' : '<'), range.end));
        }
        return havingSpecs.length === 1 ? havingSpecs[0] : { type: 'and', havingSpecs: havingSpecs };
    };
    DruidHavingFilterBuilder.prototype.versionBefore = function (neededVersion) {
        var version = this.version;
        return version && External.versionLessThan(version, neededVersion);
    };
    return DruidHavingFilterBuilder;
}());
export { DruidHavingFilterBuilder };
